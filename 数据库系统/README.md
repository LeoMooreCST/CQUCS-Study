# 数据库

## 第一章 引言

1. 数据库如何表述客观世界？

   用概念来描述事或物及其相互联系

   在关系数据库中，用二维表来描述概念，内涵（即属性）：列，外延（所有个体的集合）：行

2. 数据库阶段如何处理数据？

   数据的管理者：DBMS（数据库管理系统）

   数据面向的对象：现实世界

   数据的共享程度：共享性高

   数据的独立性：高度的物理独立性和一定的逻辑独立性

   数据的结构化：整体结构化

   数据的控制能力：由DBMS统一控制

3. 什么是数据模型？

   数据模型是一种用来抽象、表示和处理客观世界数据对象结构的描述方式。

   1. 概念模型

      按照用户的观点对数据和信息建模，是现实世界到信息世界的第一层抽象

   2. 数据模型：分为逻辑模型和物理模型

      1. 逻辑模型：主要包括网状模型、层次模型、关系模型等，是面向计算机实现建模
      2. 物理模型：是对数据最底层的抽象，描述数据在系统内部的表达方式和存取方法。

   ![image-20240527103950236](assets/image-20240527103950236.png)

4. 什么是数据？

   数据是数据库中存储和管理的基本对象

   定义：描述事物的符号记录

   种类：数字、文字、图像、声音

   特点：数据库中数据与其语义是不可分的

5. 什么是数据库？

   长期储存在计算机内的、有组织的、可共享的大量数据集合

6. 什么是DBMS？

   数据库管理系统是位于用户与操作系统之间的一层数据库管理软件

   功能：定义、操纵、数据库的运行管理、数据库的建立和维护

7. 什么是DBS？

   数据库系统是指在计算机系统引入数据库后的系统构成

   组成：数据库 + 数据库管理系统（核心） + 应用系统 + 数据库管理员（和用户）

8. 数据库技术在应用开发中的作用

   1. 数据如何存放？

      建立数据模型，逻辑结构设计，物理结构设计

   2. 数据如何访问？

      数据库语言SQL

   3. 数据如何适应应用需求变化？

      三层模式结构

   4. 如何保证数据的正确性？

      完整性约束

   5. 如何限制非法访问？

      授权管理

   6. 如何保证并发访问统一数据的有效性？

      并发管理

   7. 如何防范故障？

      数据备份与恢复

   8. 如何提高查询效率

      查询优化，索引

9. 数据库特征：

   1. 数据按一定的数据模型组织、描述和存储
   2. 可以为各种用户（应用程序）共享使用
   3. 冗余度较小
   4. 数据独立性较高
   5. 易于扩展

10. 数据库的开发运行环节

    1. 需求分析：功能需求 + 数据需求
    2. 系统设计：系统功能设计 + 数据结构设计
    3. 系统实现
    4. 系统运行与维护：运行系统与维护 + 数据运行与维护

11. 数据库设计过程：概念设计 + 逻辑设计 + 物理设计

## 第二章 概念设计-ER模型设计

1. ER模型与ER图的区别

   ER模型是一种描述方法，ER图式采用ER模型的方法，对一个具体应用的描述（结果）

2. ER模型基本要素：

   1. 实体集&属性（矩形）：描述数据内部结构，具有相同属性的实体具有相同的特征和性质，包括实体和属性
   2. 联系集（菱形及连线）：描述外部结构，联系也称关系，在信息世界中反应实体内部或实体之间的联系

3. ER模型中的联系集类型：一对一、一对多和多对多

   1. 一对一(1:1)：一个部门有一个经理，而每个经理只在一个部门任职
   2. 一对多(1:n)：每位教师可以教多门课程，但是每门课程只能由一位教师来教。
   3. 多对多(n:m)：一个学生可以学多门课程，而每门课程可以有多个学生来学。

4. 如何建立ER图：通过数据流图和数据字典来建立 或者 根据对现实世界的理解来建立

5. 如何绘制ER图：E-R图中用矩形代表实体，菱形代表关系，椭圆代表属性，直线表示属性和实体的从属关系以及连接实体及联系，下划线表示主码属性。

6. 多元联系集：一个联系相关的有多个实体集

   1. 如何将多元联系集描述转换为二元联系集描述

      ![image-20240527130031920](assets/image-20240527130031920.png)

7. 画ER图：（2-5）==属性写在矩形里面和写成椭圆的区别？？？==

   ![image-20240527131339370](assets/image-20240527131339370.png)

8. ER图设计时需要考虑的问题：

   ==一个概念应该用实体还是属性，用实体还是实体集，用实体集还是联系集，应该用二元联系还是多元联系==

   1. 实体还是实体集？

      例：xx大学包括计算机学院、通信学院、自动化学院、机械学院

      ![image-20240527132520863](assets/image-20240527132520863.png)

      不同学院有不同的属性特征

      ![image-20240527132709477](assets/image-20240527132709477.png)

      不同学院有相同的属性特征

   2. 属性应该放在什么位置？

      ![image-20240527133020846](assets/image-20240527133020846.png)

      ![image-20240527133324631](assets/image-20240527133324631.png)

      多对一或者一对一联系的属性，一般放到实体集中

      多对多联系的属性，一般放在联系集中

      ![image-20240527133634825](assets/image-20240527133634825.png)

   3. 用属性还是实体？

      当属性下有特殊属性时，要当成一个实体用联系集连接，比如工资：每个月的工资可能不同

   4. 如何处理多值属性？

      1. 将原来的多值属性用几个单值属性来代替
      2. 将原来的多值属性用一个新的实体来代替（新的实体依赖于原来的实体存在，称为弱实体）

   5. 什么是弱实体集？

      有键的实体称为强实体，无键的实体称为弱实体。

      弱实体的存在依赖于主实体。弱实体区分各个实体的属性集合称为鉴别键(discriminator)或偏键(partial key）

      弱实体集的主键由所依赖的强实体主键加上弱实体的鉴别键构成。
      在ER图上用双矩形表示弱实体集，其鉴别键加下划虚线。

      ![image-20240527141539430](assets/image-20240527141539430.png)

   6. 用实体集还是联系集？

      如果只是简单表示一个实体对另一个实体的关系，就用联系集

      如果这个关系还对其他实体有影响，就让这个关系单独作为一个实体

   7. 用二元联系还是多元联系？

      尽管能够用一组二元联系代替一个多元联系，但是若多个实体的确共同参与在一个关系中，则用多元联系能够更清晰地表达这种联系。

9. 特殊化

   1. 实体集中某些子集具有区别于该实体集内其它实体的特性，可以根据这些差异特性对实体集进行分组，这一分组的过程称作特殊化。

   2. 特殊化在ER图中的表示：

      ![image-20240527133954223](assets/image-20240527133954223.png)

10. 聚集：联系之间存在重叠，如何表达联系之间的联系？

    聚集是一种抽象，通过聚集，联系被作为实体集，实体集A与B以及它们的联系可被看成另一实体集C，使用聚集来消除冗余，将联系作为抽象实体允许联系之间存在联系，联系抽象进新的实休中

11. 例子：2-8

    ![image-20240527135056170](assets/image-20240527135056170.png)

12. 概念设计的作用是什么？

    概念:将需求分析得到的用户需求抽象为信息结构即概念模型的过程就是概念结构设计。

    概念结构独立于数据库逻辑结构，也独立于支持数据库的DBMS，是现实世界的一个真实模型，易于理解，便于和不熟悉计算机的用户交换意见，使用户易于参与。

13. 概念设计包括哪些步骤？

    1. 局部ER模式设计
    2. 全局ER模式设计
    3. 全局ER模式优化

14. 如何选择合适的局部应用？

    设计分E-R图的第一步，就是以这一层次的数据流图为出发点，设计分E-R图。
    高层的数据流图只能反映系统的概念，中层的数据流图能较好的反映系统中各局部应用的子系统组成因此往往，以中层数据流图作为设计分E-R图的依据。

15. ==各个分ER图之间的冲突主要由三类：属性冲突、命名冲突和结构冲突==

    1. 属性冲突：属性域冲突 + 属性取值单位冲突
    2. 命名冲突：同名异义 + 异名同义
    3. 结构冲突：
       1. 同一对象在不同应用中具有不同的抽象
       2. 同一实体在不同局部视图中所包含的属性不完全相同，或者属性的排列次序不完全相同。
       3. 实体之间的联系在不同局部视图中呈现不同的类型

## 第三章 关系模型

1. 什么是数据模型？

   数据模型是一个描述数据、数据联系、数据语义以及数据一致性约束概念的工具的集合。

   包括：数据结构、数据操作和约束条件

2. 哪些数据模型：==层次模型 + 网状模型 + 关系模型==

3. 层次模型：树形结构

4. 网状模型：

   1. 允许多个结点没有双亲结点，允许结点有多个双亲结点
   2. 存放方式：链接法

5. 关系模型：

   1. 无论是实体还是实体间的联系均由单一的结构类型——关系表示
   2. 是用二维表的形式表示实体和实体间联系的数据模型
   3. 关系模型的基本概念：字段为**属性**，字段值称为**属性值**，记录类型称为**关系模型**，关系模式名是**R**，记录成为**元组**，元组的集合称为**关系或实例**，一般用**大写字母**A、B、C...表示单个属性，用**小写字母**表示属性值。关系中属性的个数称为"**元数**”元组的个数称为“**基数**”，有时也称关系为表格，元组为行，属性为列。
   4. 超键：在关系中能唯一标识元组的属性集称为关系模式的超键
   5. 候选键：不含多余属性的超键称为候选键。
   6. 主键：用户选作元组标识的一个候选键称为主键
   7. 外键：保持数据一致性、完整性，控制存储在外键表中的数据，使两张表形成关联

6. 关系数据库的数据操作分为**查询**和**更新**两类。查询语句用于各种检索操作，更新操作用于插入、删除和修改等操作。

   ![image-20240528181625096](assets/image-20240528181625096.png)

7. 关系运算选择操作：

   ![image-20240528181825898](assets/image-20240528181825898.png)

8. 完整性约束：

   1. 是对关系的某种约束条件
   2. 保证关系数据库中数据的正确性和可靠性
   3. 实体完整性规则：在任何关系的任何一个元组中，主键的值不能为空值、也不能取重复的值,
   4. 域完整性规则：属性的取值范围
   5. 参照完整性规则：不允许在一个关系中引用另一个关系中不存在的元组

9. 什么是投影操作：

   1. 从关系中挑选若干属性组成的新的关系称为投影
   2. 经过投影运算能得到一个新关系，其关系所包含的属性个数往往比原关系少，或属性的排列顺序不同。
   3. 如果新关系中包含重复元组，则要删除重复元组。（如果新关系中的属性有原来的主码，就不可能重复）

   ![image-20240530154422421](assets/image-20240530154422421.png)

10. 什么是并操作？

   1. 设有两个关系R和S具有相同的关系模式，R和S的并是由属于R和S的元组构成的集合，记为RUS。

   2. 主意:R和S的元数相同（属性个数相同）

      ![image-20240530154730723](assets/image-20240530154730723.png)

11. 操作的复合：在关系代数运算中，可以灵活地把五种关系代数基本操作进行复合以满足实际应用需要这种经过有限次复合的式子称为关系代数表达式，能使用关系代数表达式表示各种数据查询操作。

12. 什么是差操作：设有两个关系R和S具有相同的关系模式，R和S的差是由属于R但不属于S的元组构成的集合记为R-S。

13. 什么是笛卡尔积：

    1. 设有设关系R和S的元数分别为r和s。定义R和S的笛卡尔积是个(r+s)元的元组集合，每个元组的前r个分量(属性值)来自R的一个元组，后s个分量来自S的一个元组，记为RxS。
    2. 若R有M个元组，S有n个元组，则RxS有mxn个元组。
    3. R和S中不能有相同的属性

14. 什么是连接运算:连接是根据给定的条件，从两个已知关系R和S的笛卡尔积中，选取满足连接条件(属性之间)的若干元组组成新的关系。

    ![image-20240530160605832](assets/image-20240530160605832.png)

15. 连接运算的四种类型：

    1. 条件连接:从两个关系的笛卡尔积中选取属性间满足一定条件的元组

       ![image-20240530161119205](assets/image-20240530161119205.png)

    2. 等值连接:从关系R与S的笛卡尔积中选取满足等值条件的元组

       ![image-20240530161151128](assets/image-20240530161151128.png)

    3. 自然连接:也是等值连接，从两个关系的笛卡尔积中，选取公共属性满足等值条件的元组，但新关系不包含重复的属性

       ![image-20240530161219899](assets/image-20240530161219899.png)

    4. 外连接:是在连接条件的某一边添加一个符号“*”，其连接结果是为符号所在边添加一个全部由“空值”组成的行

       ![image-20240530161511803](assets/image-20240530161511803.png)

       1. 左外连接：R和S进行自然连接时，只把R中舍弃的元组放到新关系中

          ![image-20240530161842699](assets/image-20240530161842699.png)

       2. 右外连接：R和S进行自然连接时，只把S中舍弃的元组放到新关系中

          ![image-20240530161853462](assets/image-20240530161853462.png)

       3. 完全外连接：R和S进行自然连接时，只把R和S中舍弃的元组都放到新关系中

16. 实体集、联系集到关系模式的转换：

    1. E-R图是数据库系统设计的概念设计阶段，之后还需要进行逻辑设计和物理设计。数据库的逻辑设计主要是将概念模型转换成一般的关系模式，也就是将E-R图中的实体、实体的属性和实体之间的联系按照一定的转换规则转化为关系模式。

    2. 关系模式：在二维表中的行定义，即对关系的描述称为关系模式。

    3. 如何将联系集转换成关系模式：

       1. 一个m:n联系可以转换为一个独立的关系模式联系两端实体的键合并组成关系模式的键，新的关系模式的属性为两端实体的键(分别作为外键)和联系的属性。

          ![image-20240530163926945](assets/image-20240530163926945.png)

       2. 一个1:m或m:1的联系:在m端实体转换成的关系模式中加入1端实体类型的键(作为外键)和联系的属性，无需创建一个新的关系模式。

          ![image-20240530164025220](assets/image-20240530164025220.png)

       3. 一个1:1的联系:联系两端的实体类型转换成两个关系模式，在任一个关系模式中加入另外一个关系模式的键(作为外键)和联系的属性。

       4. 多元联系如何转换：

          1. 若实体间联系是1:1:1，可以在三个实体类型转换成的三个关系模式中任意一个关系模式的属性中加入另两个关系模式的主键作为外键)和联系类型的属性。
          2. 若实体间联系是1:1:N，则在N端实体类型转换成的关系模式中加入两个1端实体类型的主键(作为外键)和联系类型的属性。
          3. ==若实体间联系是1:M:N，则将联系类型也转换成关系模式，其属性为M端和N端实体类型的主键(作为外键)加上联系类型的属性，而键为M端和N端实体键的组合。==
          4. 若实体间联系是M:N:P，则将联系类型也转换成关系模式，其属性为三端实体类型的主键(作为外键)加上联系类型的属性而键为三端实体键的组合。

## 第四章 SQL语言

1. SQL语言功能：

   1. 数据结构定义功能
   2. 数据操纵功能
   3. 数据控制功能

2. 如何实际建立一个关系模式结构

   ![image-20240530185112019](assets/image-20240530185112019.png)

3. 为什么要定义完整性约束：因为完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性，可以防止对数据的意外破坏。

4. 插入与删除：

   ![image-20240530190614496](assets/image-20240530190614496.png)

   ![image-20240530190623037](assets/image-20240530190623037.png)

   ![image-20240530190635966](assets/image-20240530190635966.png)

5. 属性的修改：

   ![image-20240530190738670](assets/image-20240530190738670.png)

6. 查询语句：

   1. 

   ![image-20240530190943327](assets/image-20240530190943327.png)

   2. 去除重复：distinct

      ![image-20240530191136206](assets/image-20240530191136206.png)

7. 如何实现多个关系上的数据查询;

   ![image-20240530191217584](assets/image-20240530191217584.png)

8. SQL提供了五个固有的聚集函数：

   avg	min	max	sum	count

   1. avg计算平均值

      ![image-20240530191851462](assets/image-20240530191851462.png)

   2. count计算个数

      ![image-20240530191910006](assets/image-20240530191910006.png)

9. 分组聚集：group by子句中给出的一个或多个属性是用来构造分组的。取值相同的属性会分在同一个组，然后在每个分组上进行指定的聚集运算。

   ![image-20240530192554346](assets/image-20240530192554346.png)

   ![image-20240530192604906](assets/image-20240530192604906.png)

10. having子句的用途：

    1. having子句中的谓词在形成分组后才起作用，因此可以使用聚集函数

    2. 任何出现在having子句中，但没有被聚集的属性必须出现在group by子句中

       ![image-20240530192820274](assets/image-20240530192820274.png)

11. 操作序列（顺序）：

    ![image-20240530193012111](assets/image-20240530193012111.png)

12. 更名运算as

    1. select中重命名：

       ![image-20240530193854345](assets/image-20240530193854345.png)

    2. from子句中重命名：为了适用于比较同一个关系中的元组情况，需要把关系于它自身进行笛卡尔积运算，如果不进行重命名，就不可能把一个元组与其他元组分开

       ![image-20240530195019832](assets/image-20240530195019832.png)

       （找出满足下面条件的所有教师的姓名，他们的工资至少比生物系某一个教师的工资高）

13. 字符串匹配：可以使用like操作符进行模式匹配

    1. % 匹配任意子串，'Intro%'匹配任意Intro打头的字符串，'%Comp%'匹配任意包含Comp的字符串
    2. _ 匹配任意一个字符，'_ _ _'匹配质只包含三个字符的字符串，'_ _ _ _ %'匹配至少含三个字符的字符串
    3. ![image-20240530195637337](assets/image-20240530195637337.png)

14. 排序 order by（默认升序）

    ![image-20240530195841726](assets/image-20240530195841726.png)

15. ![image-20240530195913570](assets/image-20240530195913570.png)、

    先按工资降序排列，如果有教师工资相同，再按名字升序排列

16. between 和 not between

    ![image-20240530200458237](assets/image-20240530200458237.png)

17. 嵌套子查询：

    1. where子句中

       ![image-20240531100852139](assets/image-20240531100852139.png)

    2. from子句中

       ![image-20240531101409613](assets/image-20240531101409613.png)

18. 数据更新子语言应提供哪些处理能力：

    1. 插入:将数据插入到关系表中（元组中的属性排列顺序必须与关系模式中属性排列顺序一致）

       ![image-20240531101950972](assets/image-20240531101950972.png)

       如果不记得排列顺序可以使用一下方式一一对应

       ![image-20240531102322141](assets/image-20240531102322141.png)

    2. 删除:删除已保存在关系表中的数据（如果省略where子句，就删掉r中所有元组）

       ![image-20240531102718950](assets/image-20240531102718950.png)

    3. 修改:修改已保存在关系表中的数据

       ![image-20240531103047319](assets/image-20240531103047319.png)

19. 关系连接：

    1. 自然连接（内连接）：

       ![image-20240531104425449](assets/image-20240531104425449.png)

    2. 全外连接、左外连接、右外连接

20. 视图：数据库系统的一个主要目的是给用户提供数据的抽象视图.也就是说，系统隐藏关于数据存储和维护的某些细节。

    ![image-20240531105210032](assets/image-20240531105210032.png)

    1. 视图是指计算机数据库中的一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
    2. 在查询中，视图名可以出现在关系名可以出现的任何地方。在任何给定时刻，视图关系上的元组集是该时刻视图定义的查询表达式的计算结果。
    3. 物化视图：保持最新状态的视图，当构成定义的任何关系被更新时，可以马上进行视图维护。（而不是只有视图被访问时才执行更新）

21. 完整性约束：完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性.因此完整性约束防止的是对数据的意外破坏。

    1. 键完整性约束：关系模式必须有一个主键（primary key...）

    2. 非空完整性约束：

       ![image-20240531111053798](assets/image-20240531111053798.png)

    3. ![image-20240531111204042](assets/image-20240531111204042.png)

22. 触发器：

    1. 触发器是一条语句，当对数据库作修改时，它自动被系统执行。
    2. 要设置触发器机制，必须满足两个要求：一是指明什么条件下执行触发器。它被分解为一个引起触发器被检测的事件和一个触发器执行必须满足的条件。二是指明触发器执行时的动作。

## 第五章 关系模式的优化

1. 坏关系到好关系：存在约束，特别是函数依赖，导致冗余、异常如果存在这些问题，就需要对关系模式进行优化。
2. 函数依赖：
   1. 函数依赖可形式化表示为: X→Y 其中 Xand Y是属性集。
   2. 对于关系实例r中的任意一对元组t1和t2，有t1.X = t2.X 逻辑蕴涵 t1.Y=t2.Y，那么，函数依赖 X→Y在关系r中成立。即,关系r中给定两个元组，如果 X属性值相等则 Y的值也必须相等.(X和Y是属性集)
   3. 如果对关系R中的每个实例r，都满足函数依赖则该函数依赖在关系R上成立

3. 第一范式（1NF）

   1. 每个属性都是原子属性（不可再分）

   2. 本质上所有关系都满足第一范式

4. 第二范式（2NF）

   1. 任何满足第二范式的关系满足第一范式

   2. 所有非主属性必须依赖于整个主码而不能依赖于主码的部分属性

![image-20240531134035397](assets/image-20240531134035397.png)

5. Armstrong公理:

![image-20240531134229777](assets/image-20240531134229777.png)

![image-20240531134300336](assets/image-20240531134300336.png)

![image-20240531134445737](assets/image-20240531134445737.png)

6. 函数依赖集的闭包**F+**

   1. 为什么需要计算函数依赖集的闭包 ：分析每个函数依赖，判断关系的好坏

   2. 计算方法：

      ![image-20240531135752125](assets/image-20240531135752125.png)

   3. 例子：

      ![image-20240531135827211](assets/image-20240531135827211.png)

7. 属性集的闭包：属性X的闭包X+就是由X在F上蕴含的所有属性的集合。如果X -> Y,就把Y放入X+中，反复进行。

   ![image-20240531140024648](assets/image-20240531140024648.png)

8. 属性集闭包的作用：

   1. 测试超键：检查这个闭包是不是包括关系R的所有属性。
   2. 检测函数依赖：要判断X -> Y是否成立，只需要判断Y是否在X+中。
   3. 计算F的函数依赖集闭包：将每个属性的闭包都计算出来，就可以得到所有函数依赖

9. 模式分解的基本标准：

   1. 无损连接分解：分解后的两个关系实例能够通过连接组合为原来的关系

      ![image-20240531143748227](assets/image-20240531143748227.png)

   2. 保持函数依赖：R 分解为X,Y和Z,函数依赖集FDS在X，Y，Z上成立，那么FDS也会在R上成立。

      R分解为X和Y是保持函数依赖的，当且仅当函数依赖在X和Y上的投影的并集的闭包与原来的函数依赖集闭包相同。

   3. 判断两个函数依赖集是否等价：

      如果F1+ = F2+ ，那么F1和F2等价

10. BCNF范式

    1. 任何符合BCNF的关系也符合2NF
    2. 条件：所有非平凡的函数依赖箭头左边是键。（平凡的函数依赖不用管）

11. BCNF范式分解：

    1. 当一个关系不符合BCNF范式，就需要分解它

    2. 假定关系R 包含属性A1 .. An.R的分解会分解为两个或者多个关系:每个新的关系的属性为R属性的子集(不会有属性不属于 R),并且-R 中的每一个属性至少会在一个新的关系中。直观上来说，将R分解意味着我们会用分解后的关系实例代替R的实例。

    3. 分解方法

       ![image-20240531153454038](assets/image-20240531153454038.png)

       BCNF分解一定会是保持无损连接的分解，可能会保持函数依赖。

    4. 通常情况,有多个函数依赖违背BCNF。那么我们处理它们的顺序的不同会导致分解的结果不同。可能会分解为不同的都满足BCNF的关系集。

12. 3NF

    1. 比BCNF范式弱，如果关系符合BCNF，那么必然符合3NF
    2. 允许存在一些冗余
    3. 函数依赖是否保持可以在单独的关系上检查而不需要进行连接计算。
    4. 3NF一般是保持无损连接分解和保持函数依赖。
    5. 对于F中所有的函数依赖X -> A，满足下列描述中的一个：
       1. A是X的子集（平凡函数依赖）
       2. X是超键
       3. A是R键的一部分

13. 3NF的检查方法：对于F中每一个非平凡函数依赖X->A，通过计算X的属性闭包来判断X是不是R的键，如果不是，则检查A是否属于R的键

14. 无关属性：如果取出函数依赖中的一个属性，不改变该函数依赖集的闭包，则这个属性就是无关属性。

    ![image-20240531162520250](assets/image-20240531162520250.png)

15. 正则覆盖（最小函数依赖集）

    1. 函数依赖集F的正则覆盖Fc就是F的一个等价的函数依赖集，并且Fc拥有以下性质：
       1. Fc中任何函数依赖不包含无关属性。
       2. Fc中函数依赖左半部都是唯一的。
    2. 正则覆盖求法：
       1. 先合并箭头左边相同的函数依赖
       2. 再去掉无关属性

16. 3NF分解方法：

    1. 求F的正则覆盖

    2. 由正则覆盖进行分解

       ![image-20240601161609038](assets/image-20240601161609038.png)

    3. 确定是否添加R候选键做成的子模式

       ![image-20240601161717202](assets/image-20240601161717202.png)

    4. 看是否有子模式是包含其他子模式的情况



## 第六章 物理设计

1. 数据字典

   1. 一般说来，这样“关于数据的数据”称为元数据。

   2. 关于关系的关系模式和其它元数据存储是在数据字典或者系统目录的结构中。

   3. 数据字典（Data Dictionary）是数据库管理系统中的一个重要组成部分，它是一个存储数据库元数据的集合，包含了数据库中所有对象的定义和描述信息。数据字典可以帮助用户了解数据库中的各种对象和数据结构，以及它们之间的关系和依赖关系。

   4. 数据字典通常包含以下信息：

      1. 数据库对象的定义和描述信息，包括表、视图、索引、存储过程、触发器等。

      2. 数据库对象的属性信息，包括对象的名称、类型、大小、创建时间、修改时间等。

      3. 数据库对象之间的关系和依赖关系，包括表之间的关系、视图和表之间的关系、索引和表之间的关系等。

      4. 数据库用户和权限信息，包括用户的名称、角色、权限等。

      5. 数据库参数和配置信息，包括数据库的名称、版本、字符集、时间区域等。

2. 数据库缓冲区

   1. 数据库缓冲区管理器

      ![image-20240601201413075](assets/image-20240601201413075.png)

   2. 缓冲区替换策略：

      最近最少使用块替换策略（LRU）、立即丢弃策略、最长使用策略（MRU）

   3. 索引

      1. 索引是一种与(数据库)文件相关联的附加结构，额外增加了一个辅助文件。
      2. 搜索码:用于在文件中查找记录的属性/属性组
      3. 索引项:由一个搜索码值和指向具有该搜索码值的一条/多条记录的指针构成
      4. 不是建立了索引就一定能提高查询效率

   4. 顺序索引：按顺序存储搜索码的值
   
      1. 顺序索引分为两种类型：主索引 + 辅助索引
      2. 主索引(聚集索引):索引文件排序与数据文件排序相同(只能有一个)
      3. 辅助索引(非聚集索引):索引文件排序与数据文件排序不相同(可多个)
      4. 顺序索引的实现类型：稠密索引和稀疏索引
         1. 稠密索引:索引文件中每个搜索码都有一个索引项（稠密索引次序可不同）
         2. 稀疏索引:索引文件中只为某些搜索码建立索引项（必须是主索引，即次序必须与数据文件排序相同）
         3. 稠密索引和稀疏索引优缺点：
            1. 稠密索引可以比稀疏索引更快的查找一条记录
            2. 稀疏索引占空间较小，插入和删除时所需要维护的开销较小
   
   5. 散列索引：采用散列函数将搜索码映射到散列桶
   
      1. 散列函数：令K表示所有搜索码值的集合，令B表示所有桶地址的集合。散列函数h是一个从K到B的函数。我们用h表示散列函数。
      2. 为了插入一条搜索码为Ki的记录，我们计算h(Ki)，它给出了存放该记录的桶的地址。我们目前假定桶中有容纳这条记录的空间，于是这条记录就存储到该桶中。
      3. 最希望的是具有分布特性的函数分布是均匀的。即散列函数从所有可能的搜索码值集合中为每个桶分配同样数量的搜索码值。
      4. 分布是随机的。在一般情况下，不管搜索码值实际怎样分布，每个桶应分配到的搜索码值的数自几平相同
      5. 溢出桶：散列函数计算出来搜索码的值均匀的分别在桶里。但是一般情况下，不是很均匀。有的桶会装满，之后相应的值就没办法装到这个桶里。因此，就必然要使用溢出桶。（溢出桶可能有多个）
   
   6. 散列索引方法：
   
      1. 插入一个索引项：计算搜索码的散列值确定桶然后在相应桶中写入索引项
      2. 删除一个索引项：计算搜索码的散列值确定桶然后在相应桶中删除索引项
      3. 查找记录：计算搜索码的散列值确定桶然后在相应桶中得到索引项根据索引项中指针得到记录
   
   7. 静态散列桶的数量是固定的：散列函数h将搜索码值映射到一个地址中的固定桶集合B上，如果为了处理将来文件的增长而将B取得较大，就会浪费空间，如果B太小一个桶中就会包含许多具有不同的搜索码值的记录，从而发生桶溢出。
   
   8. 动态散列
   
      1. 可扩充散列：当数据库增大或缩小时，可扩充散列可以通过桶的分裂或合并来适应数据库大小的变化。
         1. 使用可扩充散列时，我们选择一个具有均匀性和随机性特征的散列函数h。
         2. 我们并不为每个散列值创建一个桶。相反，我们是在记录插入文件时按需要建桶。
         3. 要插入一个搜索码值为K1的记录，系统按上述相同过程进行查找，最终定位到某个桶假定为桶j，如果该桶有空间，则插入。如果已满，系统必须分裂这个桶并将该桶中现有记录和新记录一起进行分配。、
   



## 第七章 查询处理与优化

1. 查询代价的度量：查询处理的代价可以通过该查询对各种资源的使用情况进行度量。

2. 在大型数据库系统中，在磁盘存取数据的代价通常是最主要的代价。

3. 选择操作典型实现方法：

   1. 简单的全表扫描方法
   2. 索引（散列）扫描的方法

4. 连接操作的实现

   1. 嵌套循环方法：
      1. 对外层循环(Student)的每一个元组(s)
      2. 索内层循环(SC)中的每一个元组(sc)检查这两个元组在连接属性(sno)上是否相等
      3. 如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止
   2. 排序合并方法：
      1. 如果连接的表没有排好序，先对Student表和SC表按连接属性Sno排序
      2. 取Student表中第一个Sno，依次扫描SC表中具有相同Sno的元组
      3. 扫描到Sno不相同的第一个SC元组时返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组，把它们连接起来重复上述步骤直到Student 表扫描完
   3. 索引连接方法：
      1. 在SC表上建立属性Sno的索引。(如果原来没有没有该索引）
      2. 对Student中每一个元组，由Sno值通过SC的索引查找相应的SC元组。
      3. 把这些SC元组和Student元组连接起来，循环执行②③，直到Student表中的元组处理完为止。
   4. Hash Join方法：把连接属性作为hash码，用同一个hash函数把R和S中的元组散列到同一个hash文件中
      1. 划分阶段：对包含较少元组的表(比如R)进行一遍处理把它的元组按hash函数分散到hash表的桶中
      2. 试探阶段:也称为连接阶段对另一个表(S)进行一遍处理把S的元组散列到适当的hash桶中把元组与桶中所有来自R并与之相匹配的元组连接起来

5. “选择下移”优化策略：先做选择再做连接

   ![image-20240602155000874](assets/image-20240602155000874.png)

6. ”投影下移“优化策略：通过先投影，去除不必要的属性，可以减少中间结果的列数，从而减少中间结果的大小。

   ![image-20240602155218241](assets/image-20240602155218241.png)

7. ”选择连接顺序“优化策略：小关系的连接应该优先于大关系的连接

   ![image-20240602155753198](assets/image-20240602155753198.png)



## 第八章 事务

1. 事务：是指访问并可能更新各种数据项的一个程序执行单元。

   1. 事务是一个单一的、不可分割的单元，要么完整地执行要么完全地不执行。

   2. 事务是一个最小的工作单元，不论成功与否都作为一个整体进行工作。不会有部分完成的事务。由于事务是由几个任务组成的，如果一个事务作为一个整体是成功的则事务中的每个任务都必须成功。如果事务中有一部分失败，则整个事务失败。

   3. 中止事务:执行中发生故障、不能执行完成的事务;

   4. 事务回滚:将中止事务对数据库的更新撤消掉

   5. 已提交事务:成功执行完成的事务。注意:事务一旦提交，就不能中止它

   6. ![image-20240602162528760](assets/image-20240602162528760.png)

   7. 数据库事务的四个基本特性（ACID特性）：

      1. 原子性

         原子性用于标识事务是否完全地完成，一个事务的任何更新要在系统上完全完成，如果由于某种原因出错，事务不能完成它的全部任务，系统将返回到事务开始前的状态。

      2. 一致性

         如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。因为事务开始时系统处于一致状态，所以现在系统仍然处于一致状态。

      3. 隔离性

         在隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。

      4. 持久性

         持久性意味着一旦事务执行成功，在系统中产生的所有变化将是永久的。

2. 调度：调度是一个或多个事务的重要操作(read ，write，COMMIT，ROLLBACK)按时间排序的一个序列。使得来源于任何事务T的任意两个动作在该序列中出现的先后关系与它们在事务T中出现的顺序保持一致。

   1. 串行调度：非交错地依次执行给定事务集合中每一个事务的全部动作。
   2. 并发调度: 交错执行各事务中操作的一个动作序列。

3. 可串行化调度：

   1. 对于给定任何n个事务的集合，如果允许它们并发执行，则按任意顺序串行地执行它们都是有效的。
   2. 可串行化调度:如果不管数据库初态怎样，一个调度对数据库状态的影响都和某个串行调度相同，我们称该调度具有可串行性(Serializability)也说它是可串行化的。
   3. 冲突指令：当不同事务的两个指令同时对一个数据项进行访问，且其中至少一个指令是写操作时，就称为冲突指令。
   4. 冲突等价：根据指令的冲突与不冲突，将调度中的非冲突指令交换执行顺序，如果调度S可以经过一系列非冲突指令交换转换成S'，我们称S和S'是冲突等价的。
   5. 若一个调度S与一个串行调度冲突等价，则称调度S是冲突可串行化的。
   6. ![image-20240602164823604](assets/image-20240602164823604.png)
   7. ![image-20240602165037409](assets/image-20240602165037409.png)

4. 可恢复调度:

   1. 对于每对事务T1与T2，如果T2读取了T1所写的数据，则T1必须先于T2提交。
   2. 级联回滚:因单个事务故障导致一系列事务回滚的现象称为级联回滚。（希望不发生级联回滚）
   3. 因此无级联调度应满足:对于每对事务T1与T2如果T2读取了T1所写的数据，则T1必须在T2读取之前提交。
   4. 我们希望调度是可恢复的并且是无级联的

5. 脏读：A事务读取B事务尚末提交的更改数据，并在这个数据的基础上进行操作，这时候如果事务B回滚，那么A事务读到的数据是不被承认的。

6. 不可重复读：是指读到了已经提交的事务的更改数据(修改或删除)



## 第九章 并发控制

1. 并发：多个事务同时在系统中执行

2. 封锁：就是事务在对某个数据项操作之前，先向系统发出请求，对其加锁，加锁后，事务就对该数据项有一定的控制，在事务释放它的锁之前，其他事务不能更新此数据项。一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定

3. 基本锁类型包括：排它锁（X锁） + 共享锁（S锁）

4. 排它锁：又称为写锁，若事务T对数据项A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁，保证其他事务在T释放A上的锁之前不能再读取和修改A。

5. 共享锁：又称为读锁，若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

6. 要访问一个数据项，事务Ti必须首先给该数据项加锁，如果该数据项已被另一事务加上了不相容的锁，则Ti只能等待其他事务解锁。

7. 相容矩阵

   ![image-20240603141458136](assets/image-20240603141458136.png)

8. 仅仅有封锁不能保证事务的可串行化

9. 封锁协议：系统中每一个事务都应该遵从一组规则，这些规则规定了事务何时对数据项进行加锁、解锁。这些规则称为封锁协议。

10. 死锁：如果存在一个事务集，该集合中的每个事务都在等待集合中的另外一个事务，我们就说系统处于死锁状态。

11. 活锁：出现一个事务永远(长时间)等待某一数据项被其它事务释放后才能进行封锁的现象

    ![image-20240603142458921](assets/image-20240603142458921.png)

12. 两阶段封锁协议：

    1. 第一阶段：获得封锁，也称为扩展阶段

    2. 第二阶段：释放封锁，也称为收缩阶段

    3. 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁

    4. 在释放一个封锁之后，事务不能再获得任何其他封锁。

    5. 也就是说，一开始，事务处于增长阶段，事务很据需要获得锁。一旦该事务释放了锁，它就进入缩减阶段，不能再发出加锁请求

       ![image-20240603142808540](assets/image-20240603142808540.png)

    6. 两阶段封锁是可串行化调度的充分条件，而不是必要条件。

    7. 严格两阶段封锁协议除了要求封锁是两阶段之外，还要求事务持有的所有排它锁必须在事务提交之后方可释放。

    8. 强两阶段封锁协议要求事务提交之前不得释放任何锁。使用锁机制的数据库系统，要么使用严格两阶段封锁协议，要么使用强两阶段封锁协议。

    9. 两阶段封锁协议并不保证不会发生死锁。

13. 死锁预防：预先防止死锁发生，保证系统永不进入死锁状态;

    两种方法：

    1. 通过对加锁请求进行排序或者要求同时获得所有的锁来保证不会发生循环等待

    2. 另一种方法比较接近死锁恢复，每当等待有可能导致死锁时，进行事务回滚而不是等待加锁。

    3. 利用时间戳的两种不同的死锁预防机制：

       1. 等待-死亡机制：

          ![image-20240603144208591](assets/image-20240603144208591.png)

       2. 受伤-等待机制：

          ![image-20240603144235336](assets/image-20240603144235336.png)

       3. 等待上的区别：

          ![image-20240603144258437](assets/image-20240603144258437.png)

       4. 回滚上的区别：

          ![image-20240603144329189](assets/image-20240603144329189.png)

14. 死锁检测与恢复：允许系统进入死锁状态但要周期性地检测系统有无死锁。如果有则把系统从死锁中恢复过来

    1. 检测系统状态的算法周期性的激活，判断有无死锁发生。如果发生死锁，则系统必须试着从死锁中恢复。
    2. ![image-20240603144527865](assets/image-20240603144527865.png)

15. 多粒度锁封锁：封锁的对象的大小称为封锁粒度

    1. 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；反之，封锁的粒度越小，并发度较高，但系统开销也就越大。

    2. 主要内容：

       1. 允许多粒度树中的每一个结点被独立地加锁。

       2. 对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。

       3. 显式封锁：直接加到数据对象上

       4. 隐式封锁：该数据对象没有显式地被封锁，是由于其上级节点加锁而使得该数据对象加了锁。

       5. 无论是显式封锁还是隐式封锁，效果都是一样的

       6. 意向锁：如果一个结点加上意向锁，意味着要在树的较低层进行显式加锁。在一个结点显式加锁前，该结点的全部祖先结点均加上意向锁。因此，事务不必搜索整棵树就能判定能否成功对一个结点加锁。

          ![image-20240603145505332](assets/image-20240603145505332.png)

16. 时间戳：对于系统中每一个事务Ti，我们把一个唯一的固定时间戳和它联系起来，此时间戳记为TS(Ti)。

    1. 若事务Ti已赋予时间戳TS(Tì)，此时有一个新事务Tj进入系统，则TS(Ti)<TS(Tj)
    2. 在时间戳机制中，每个数据项Q需要和以下两个重要的时间戳相关联：
       1. W-TS(Q):表示当前已成功执行write(Q)的所有事务的最大时间戳;
       2. R-TS(Q):表示当前已成功执行read(Q)的所有事务的最大时间戳。
       3. 每当有新的read(Q)或write(Q)指令成功执行，这两个时间戳就被更新。

17. 时间戳排序协议：是按照事务的时间戳顺序来处理事务之间的冲突操作，

    1. 满足时间戳排序协议的任何调度都能保证：
       1. 冲突可串行化
       2. 无死锁，因为冲突的事务被回滚重启并赋予新的时间戳，而不是等待执行。
    2. ![image-20240603150650487](assets/image-20240603150650487.png)
    3. ![image-20240603150933006](assets/image-20240603150933006.png)



## 第十章 数据库恢复机制

1. 故障类型：

   1. 事务故障：
      1. 逻辑错误:事务由于某些内部条件而无法继续正常执行，这样的内部条件如非法输入、找不到数据、溢出或超出资源限制。
      2. 系统错误:系统进入一种不良状态(如死锁)结果事务无法继续正常执行，但该事务可以在以后的某个时间重新执行。
   2. 系统故障：硬件故障，或者是数据库系统或操作系统的漏洞，导致易失性存储器内容的丢失，并使得事务处理停止，而非易失性存储器仍完好无损。
   3. 磁盘故障：在数据传送操作过程中由于磁头损坏或故障造成磁盘块上的内容丢失。其他磁盘上的数据拷贝，或三级介质(如DVD或磁带)上的归档备份可用于从这种故障中恢复。

2. 日志：日志是最常用的用于记录数据库修改的结构，它是日志记录的序列，记录了数据库中的所有更新活动

   1. 常用日志记录格式：

      ![image-20240603153923670](assets/image-20240603153923670.png)

   2. 登记日志的原则：

      1. 登记的次序严格按照并行事务执行的时间次序
      2. 必须先写日志文件，后写数据库

   3. 事务故障的恢复策略：反向扫描日志文件，对该事务的更新操作执行逆操作(即将日志中更新前的数据写回到数据库中)，直至事务的开始标志。

   4. 系统故障的恢复策略：撤销故障发生时未完成的事务，重做已完成的事务

      1. 方法:扫描日志文件;找出故障发生前提交的事务让该事务重做(REDO);找出故障发生前未提交的事务，让其撤销(UNDO)。

      2. abort事务中止记录

         ![image-20240603155838606](assets/image-20240603155838606.png)

      3. 在构建了redo队列和undo队列之后，分别对两个队列中的事务进行恢复处理

      4. ![image-20240603160152217](assets/image-20240603160152217.png)

      5. 系统故障的恢复也就是对系统中所有事务的故障恢复。

3. 检查点：引入检查点。在运行过程中，DBMS一般每隔一定的时间在日志记录中设置一个检查点，在日志中加入<Checkpoint L>记录。

   1. 在系统崩溃后，系统检查日志以找到最后一条检查点记录，只需要对L中的事务以及检查点记录写到日志中之后才开始执行的事务进行撤销或重做操作;
   2. 考虑在检查点前完成的事务Ti。<Ticommit>记录(或<Tiabort>记录)在日志中出现检查点记录之前，Ti所作的任何数据库修改都必然已在检查点之前或作为检查点本身的一部分写入数据库。因此，在恢复时就不必再对T执行重做操作。
   3. ![image-20240603160654031](assets/image-20240603160654031.png)
   4. ![image-20240603161619241](assets/image-20240603161619241.png)



## 第十一章 体系结构

1. 集中式系统：集中式系统是指运行在单台计算机上，不与其他计算机系统交互的数据库系统。

   1. 使用计算机的方式：单用户系统和多用户系统
   2. 在集中式系统中， DBMS和应用程序以及与用户终端进行通信的软件等都运行在一台宿主计算机上，所有的数据处理都是在宿主计算机中进行。

2. 客户/服务系统（C/S系统）

   ![image-20240603164112979](assets/image-20240603164112979.png)

3. 浏览器/服务器系统（B/S系统）

   ![image-20240603164331536](assets/image-20240603164331536.png)

   ![image-20240603164416362](assets/image-20240603164416362.png)

   ![image-20240603164454255](assets/image-20240603164454255.png)

4. RDBMS结构：关系数据库管理系统(RelationalDatabase Management System),是将数据组织为相关的行和列的系统，而管理关系数据库的计算机软件就是关系数据库管理系统。

   1. 层次结构

      ![image-20240603164701613](assets/image-20240603164701613.png)

   2. 应用层：位于RDBMS之外。它处理的对象是各种各样的数据库应用，如用开发工具开发的或用宿主语言编写的应用程序，终端用户通过通过应用接口发出事务请求或各种查询。该层是RDBMS与终端用户或者应用程序的接口层。

   3. 语言翻译处理层：它处理的对象是数据库语言。向上提供的数据接口是关系表、视图等。其功能是对数据库语言的各类语句进行语法分析、视图转换、权限检查、完整性检查查询优化等。通过对下层基本模块的调用生成可执行代码。这些代码的运行即可完成数据库语句的功能要求。

   4. 数据存取层：该层处理的对象是数据表的单行。它把上层的集合操作转换为单行记录操作执行扫描(如表扫描 Table Scan)、排序(Sort)、数据查找、插入(Insert)、修改(Update)、删除(Delete)、封锁等基本操作。完成数据记录的存取、存取路径维护并发控制、事务管理等工作。

   5. 数据存储层：该层处理的对象是数据页和系统缓冲区。执行文件的逻辑打开、关闭、读页、写页缓冲区读和写、页面淘汰等操作，完成缓冲区管理、内外存交换、外存的数据管理等功能。

   6. 操作系统：操作系统是RDBMS运行和存在的基础。它处理的对象是数据文件的物理块。执行物理文件的读写操作，保证RDBMS对数据逻辑上的读写真实的映射到物理文件上。

## 第十二章 习题要点

1. ==主数据文件的后缀是mdf==
   ==次数据文件的后缀是ndf==
   ==日志文件的后缀是ldf==

2. SQL Server有四大默认数据库：Master、Model、Tempdb、Msdb。
   Master：
     Master是SQL Server的主数据库，存放SQL Server所有元数据信息和一些基础信息。
   Model：
     Model是SQL Server的模型数据库，是用来创建新数据库的模板数据库，可以存放任何存储过程、视图、用户等内容。创建新数据库时，新数据库会存放模型数据库的所有对象。
   Tempdb：
     Tempdb用来存放临时对象，该数据库在实例重启后会重建。相关对象是根据Model数据库定义的对象创建的。该数据库会存放临时表、变量以及所有数据库的对象类型。
   Msdb：
     Msdb是SQL Server用来保存备份、SQL Agent信息、DTS程序包和SQL Server任务等信息，以及复制信息等。

3. 完整性约束：实体完整性 + 域完整性 + 参照完整性 + 用户自定义完整性

4. SQL Server六大约束：

   1. not null非空约束
   2. default默认值约束
   3. primary key主键约束
   4. unique唯一约束
   5. check检查约束
   6. foreign key外键约束

5. 主索引(聚集索引):索引文件排序与数据文件排序相同(只能有一个)

   辅助索引(非聚集索引):索引文件排序与数据文件排序不相同(可多个)

6. 规则（ Rule ） 就是数据库中对存储在表的列或用户自定义数据类型中的值的规定和限制。规则是单独存储的独立的数据库对象。规则与其作用的表或用户自定义数据类型是相互独立的，即==表或用户自定义对象的删除、修改不会对与之相连的规则产生影响==。规则和约束可以同时使用，表的列可以有一个规则及多个 CHECK 约束。

   1. *只有将规则绑定到列或用户自定义数据类型时，规则才起作用。*
   2. ==表中的每列或每个用户定义数据类型只能和一个规则绑定==。==但每列可应用多个CHECK约束==。
   3. 如果要删除规则，应确定规则已经解除绑定。

7. SQL中语言可分为：数据库查询语言（DQL）SELECT  数据库定义语言（DDL）创建、修改和删除数据库对象	 数据库操作语言（DML）插入、更新和删除数据库中的数据	数据控制语言（DCL）控制对数据库的访问和操作权限	事务控制语言（TCL）

8. 连接查询三种：内连接、外连接和交叉连接

   1. 内连接又分为等值连接、自然连接和条件连接
   2. 外连接分为左外连接、右外连接、完全外连接
   3. 交叉连接：生成笛卡尔积

9. 关系模型的基本概念：字段为**属性**，字段值称为**属性值**，记录类型称为**关系模型**，关系模式名是**R**，记录成为**元组**，元组的集合称为**关系或实例**，一般用**大写字母**A、B、C...表示单个属性，用**小写字母**表示属性值。关系中属性的个数称为"**元数**”元组的个数称为“**基数**”，有时也称关系为表格，元组为行，属性为列。

10. 投影可以去重

11. 数据库系统的核心是数据库管理系统

12. 数据库数据太大，主数据文件如果存放不了，就会存放到次要文件中。次数据文件可以没有，也可以有多个

13. 事务日志用于保存对数据的更新操作

14. **数据库系统的三级模式结构**：内模式、模式和外模式

    **外模式**（External Schema）又称为子模式（Subschema）或用户模式（User Schema），外模式是三级结构的最外层，是数据库用户能看到并允许使用的那部分局部数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示，也是数据库用户的数据视图，即用户视图。可见，外模式一般是模式的子集，一个数据库可以有多个外模式。由于不同用户的需求可能不同，因此，不同用户对应的外模式的描述也可能不同。另外，同一外模式也可以为某一用户的多个应用系统所使用。因此，各个用户可根据系统所给的外模式，用查询语言或应用程序去操作数据库中所需要的那部分数据，这样每个用户只能看到和访问所对应的外模式中的数据，数据库中的其余数据对他们来说是不可见的。所以，外模式是保证数据库安全性的有力措施。模式也称逻辑模式（Logical Schema）或概念**模式**（Conceptual Schema），是数据库全体数据的逻辑结构和特征的描述。模式处于三级结构的中间层，不涉及数据的物理存储细节和硬件环境，与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。一个数据库只有一个模式，因为它是整个数据库数据在逻辑上的视图，即是数据库的整体逻辑。

    **内模式**又称储存模式（Storage Schema）或物理模式（Physical Schema），是三级模式中的最内层，也是最靠近物理存储的一层，即与实际存储数据方式有关的一层。它是对数据库存储结构的描述，是数据在数据库内部的表示方式。例如，记录以什么存储方式存储（顺序存储、B+树存储）、索引按照什么方式组织、数据是否压缩、是否加密等。一个数据库只有一个内模式。

15. 范式的作用：消除数据冗余、更新异常、插入异常和删除异常

16. ER图中的冲突：属性冲突、命名冲突和结构冲突

17. 事务的特性：原子性、一致性、隔离性、持续性

18. **数据**是数据库中存储和管理的基本对象

19. **数据库**：长期储存在计算机内的、有组织的、可共享的大量数据集合

20. **DBMS**数据库管理系统是位于用户与操作系统之间的一层数据库管理软件

    功能：定义、操纵、数据库的运行管理、数据库的建立和维护

21. **DBS**数据库系统是指在计算机系统引入数据库后的系统构成

    组成：数据库 + 数据库管理系统（核心） + 应用系统 + 数据库管理员（和用户）

22. 数据库的故障类型：事务故障、系统故障、介质故障

23. 关系操作的特点是集合操作

24. 数据库设计过程：需求分析 + 概念结构设计 + 逻辑结构设计 + 物理结构设计 + 数据库实施 + 数据库运行和维护

25. 三级封锁协议：

    1. 一级：修改之前加X锁
    2. 二级：读加S锁，写加X锁
    3. 三级：读写加锁直到事务结束

